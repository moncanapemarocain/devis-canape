"""
Module de calcul des devis pour canapés marocains.

Ce module expose la fonction ``calculer_prix_total`` qui, à partir d’une
configuration de canapé et des valeurs mesurées par le module de rendu
(`canapematplot.py`), calcule un prix TTC détaillé.  Il tient compte des
dimensions des mousses, du tissu, des supports (banquettes, banquettes
d’angle, dossiers), des coussins (65 cm, 80 cm, 90 cm et valise), des
traversins, des surmatelas, des accoudoirs et des arrondis.  Les
formules et tarifs appliqués suivent les directives fournies par
l’utilisateur.

Principales règles :

* **Mousses** : pour chaque mousse droite ou d’angle, le prix TTC est
  calculé par :

      (longueur * largeur * épaisseur * densité * 22) / 1 000 000

  où les dimensions proviennent du rapport console, l’épaisseur est
  saisie par l’utilisateur (cm) et la densité dépend du type de mousse
  (D25 → 25, D30 → 30, HR35 → 35, HR45 → 45).

* **Tissu** : pour chaque mousse, si ``largeur + (épaisseur * 2) > 140``
  alors le coût est ``(longueur/100) * 105``, sinon ``(longueur/100) * 74``.

* **Supports** : banquette droite = 250 €, banquette d’angle = 250 €, dossier = 250 €.
  Chaque accoudoir est facturé 200 €.

* **Coussins** : coussins d’assise et décoratifs sont comptés selon leur
  taille : 65 cm → 40 €, 80 cm → 50 €, 90 cm → 55 €, valise → 75 €.
  Les coussins déco supplémentaires coûtent 15 € pièce.

* **Traversins** : 30 € l’unité ; **Surmatelas** : 80 € l’unité.

* **Arrondis** : si l’option est activée, un supplément de 20 € est
  ajouté par banquette droite et par banquette d’angle.

La fonction renvoie un dictionnaire contenant :

``prix_ht`` : montant hors taxe (TTC / 1,20),
``cout_revient_ht`` : estimation simplifiée du coût de revient (70 % du HT),
``tva`` : montant de la TVA (TTC − HT),
``total_ttc`` : total toutes taxes comprises,
``calculation_details`` : liste détaillée des calculs (chaque entrée avec la
 catégorie, l’article, la quantité, la formule utilisée et le total).

Le module charge dynamiquement ``canapematplot.py`` pour obtenir les
dimensions et quantités imprimées en console.  En cas d’erreur, une
``RuntimeError`` est levée afin que l’application Streamlit puisse
afficher un message compréhensible.
"""

from __future__ import annotations

import contextlib
import importlib.machinery
import io
import os
import re
from typing import Dict, List, Tuple


def _load_canape_module() -> object:
    """Charge et retourne le module de rendu (canapematplot.py).

    Ce chargeur utilise ``importlib.machinery.SourceFileLoader`` pour
    importer un fichier Python dont le nom est fixé (canapematplot.py).
    Les appels bloquants comme ``plt.show`` et ``turtle.done`` sont
    neutralisés afin que le rendu graphique ne bloque pas le calcul.
    """
    global _CANAPE_MOD
    if '_CANAPE_MOD' in globals() and _CANAPE_MOD is not None:
        return _CANAPE_MOD
    this_dir = os.path.dirname(os.path.abspath(__file__))
    filename = 'canapematplot.py'
    path = os.path.join(this_dir, filename)
    if not os.path.exists(path):
        raise FileNotFoundError(f"Cannot find the canape rendering module at {path!r}")
    loader = importlib.machinery.SourceFileLoader('canape_render', path)
    mod = loader.load_module()
    try:
        import matplotlib
        matplotlib.use('Agg', force=True)
    except Exception:
        pass
    try:
        mod.plt.show = lambda *args, **kwargs: None  # type: ignore[attr-defined]
    except Exception:
        pass
    try:
        mod.turtle.done = lambda *args, **kwargs: None  # type: ignore[attr-defined]
    except Exception:
        pass
    globals()['_CANAPE_MOD'] = mod
    return mod


def _call_render_function(mod: object, *, type_canape: str, tx: float | int | None, ty: float | int | None,
                          tz: float | int | None, profondeur: float | int | None, dossier_left: bool, dossier_bas: bool,
                          dossier_right: bool, acc_left: bool, acc_bas: bool, acc_right: bool,
                          meridienne_side: str | None, meridienne_len: float | int | None,
                          coussins: str | int | None) -> str:
    """Appelle la fonction de rendu appropriée et capture la sortie console."""
    try:
        render_func: callable
        kwargs: Dict[str, object] = {}
        t = (type_canape or '').lower()
        if 'simple' in t:
            render_func = getattr(mod, 'render_Simple1')
            kwargs = dict(
                tx=tx,
                profondeur=profondeur,
                dossier=dossier_bas,
                acc_left=acc_left,
                acc_right=acc_right,
                meridienne_side=meridienne_side,
                meridienne_len=meridienne_len or 0,
                coussins=coussins or 'auto',
                window_title="simple"
            )
        elif 'l - sans angle' in t:
            render_func = getattr(mod, 'render_LNF')
            kwargs = dict(
                tx=tx,
                ty=ty,
                profondeur=profondeur,
                dossier_left=dossier_left,
                dossier_bas=dossier_bas,
                acc_left=acc_left,
                acc_bas=acc_bas,
                meridienne_side=meridienne_side,
                meridienne_len=meridienne_len or 0,
                coussins=coussins or 'auto',
                variant="auto",
                window_title="LNF"
            )
        elif 'l - avec angle' in t:
            render_func = getattr(mod, 'render_LF_variant')
            kwargs = dict(
                tx=tx,
                ty=ty,
                profondeur=profondeur,
                dossier_left=dossier_left,
                dossier_bas=dossier_bas,
                acc_left=acc_left,
                acc_bas=acc_bas,
                meridienne_side=meridienne_side,
                meridienne_len=meridienne_len or 0,
                coussins=coussins or 'auto',
                window_title="LF"
            )
        elif 'u - sans angle' in t or (('u ' in t) and ('sans angle' in t)):
            render_func = getattr(mod, 'render_U')
            kwargs = dict(
                tx=tx,
                ty_left=ty,
                tz_right=tz,
                profondeur=profondeur,
                dossier_left=dossier_left,
                dossier_bas=dossier_bas,
                dossier_right=dossier_right,
                acc_left=acc_left,
                acc_bas=acc_bas,
                acc_right=acc_right,
                coussins=coussins or 'auto',
                variant="auto",
                window_title="U"
            )
        elif 'u - 1 angle' in t:
            render_func = getattr(mod, 'render_U1F_v1')
            kwargs = dict(
                tx=tx,
                ty=ty,
                tz=tz,
                profondeur=profondeur,
                dossier_left=dossier_left,
                dossier_bas=dossier_bas,
                dossier_right=dossier_right,
                acc_left=acc_left,
                acc_right=acc_right,
                meridienne_side=meridienne_side,
                meridienne_len=meridienne_len or 0,
                coussins=coussins or 'auto',
                window_title="U1F"
            )
        elif 'u - 2 angles' in t:
            render_func = getattr(mod, 'render_U2f_variant')
            kwargs = dict(
                tx=tx,
                ty_left=ty,
                tz_right=tz,
                profondeur=profondeur,
                dossier_left=dossier_left,
                dossier_bas=dossier_bas,
                dossier_right=dossier_right,
                acc_left=acc_left,
                acc_bas=acc_bas,
                acc_right=acc_right,
                meridienne_side=meridienne_side,
                meridienne_len=meridienne_len or 0,
                coussins=coussins or 'auto',
                variant="auto",
                window_title="U2F"
            )
        else:
            raise ValueError(f"Unrecognised type_canape: {type_canape}")
        buf = io.StringIO()
        with contextlib.redirect_stdout(buf):
            render_func(**kwargs)  # type: ignore[func-returns-value]
        return buf.getvalue()
    except Exception as exc:
        raise RuntimeError(f"Erreur lors de l'exécution du rendu: {exc}") from exc


def _parse_console_report(report: str) -> Dict[str, object]:
    """Analyse les lignes émises dans la console par le module de rendu.

    On extrait les nombres de banquettes, banquettes d’angle, dossiers,
    accoudoirs, les dimensions de chaque mousse (droite ou angle) et le
    nombre de coussins de chaque taille, ainsi que les traversins.  Les
    valeurs absentes sont initialisées à 0 ou listes vides.
    """
    result: Dict[str, object] = {
        'nb_banquettes': 0,
        'nb_banquettes_angle': 0,
        'nb_dossiers': 0,
        'nb_accoudoirs': 0,
        'dims_mousses': [],
        'dims_mousses_angle': [],
        'nb_coussins_65': 0,
        'nb_coussins_80': 0,
        'nb_coussins_90': 0,
        'nb_coussins_valise': 0,
        'nb_traversins': 0,
    }
    lines = [line.strip() for line in report.splitlines() if line.strip()]
    pat_int = re.compile(r"\d+")
    pat_mousse = re.compile(r"^Dimension mousse\s+(\d+)\s*:\s*([0-9]+)\s*,\s*([0-9]+)")
    pat_mousse_angle = re.compile(r"^Dimension mousse angle\s+(\d+)\s*:\s*([0-9]+)\s*,\s*([0-9]+)")
    for line in lines:
        if line.lower().startswith('nombre de banquettes'):
            m = pat_int.search(line)
            if m:
                result['nb_banquettes'] = int(m.group())
        elif 'banquette d’angle' in line.lower() or 'banquette d\'angle' in line.lower():
            m = pat_int.search(line)
            if m:
                result['nb_banquettes_angle'] = int(m.group())
        elif line.lower().startswith('nombre de dossiers'):
            m = pat_int.search(line)
            if m:
                result['nb_dossiers'] = int(m.group())
        elif line.lower().startswith('nombre d’accoudoir') or line.lower().startswith("nombre d'accoudoir"):
            m = pat_int.search(line)
            if m:
                result['nb_accoudoirs'] = int(m.group())
        elif line.lower().startswith('dimension mousse angle'):
            m = pat_mousse_angle.match(line)
            if m:
                L = float(m.group(2)); P = float(m.group(3))
                result['dims_mousses_angle'].append((L, P))
        elif line.lower().startswith('dimension mousse'):
            m = pat_mousse.match(line)
            if m:
                L = float(m.group(2)); P = float(m.group(3))
                result['dims_mousses'].append((L, P))
        elif 'nombre de coussins 65' in line.lower():
            parts = line.split(':')
            if len(parts) >= 2:
                try:
                    qty = int(re.findall(r"\d+", parts[1])[0])
                    result['nb_coussins_65'] = qty
                except Exception:
                    pass
        elif 'nombre de coussins 80' in line.lower():
            parts = line.split(':')
            if len(parts) >= 2:
                try:
                    qty = int(re.findall(r"\d+", parts[1])[0])
                    result['nb_coussins_80'] = qty
                except Exception:
                    pass
        elif 'nombre de coussins 90' in line.lower():
            parts = line.split(':')
            if len(parts) >= 2:
                try:
                    qty = int(re.findall(r"\d+", parts[1])[0])
                    result['nb_coussins_90'] = qty
                except Exception:
                    pass
        elif 'nombre de coussins valises' in line.lower():
            m = pat_int.search(line)
            if m:
                result['nb_coussins_valise'] = int(m.group())
        elif 'nombre de traversin' in line.lower():
            m = pat_int.search(line)
            if m:
                result['nb_traversins'] = int(m.group())
        else:
            continue
    return result


def _density_from_type(type_mousse: str) -> float:
    """Convertit une chaîne Dxx/HRxx en densité numérique."""
    if not type_mousse:
        return 25.0
    t = str(type_mousse).strip().lower()
    if 'hr' in t:
        try:
            return float(t.replace('hr', '').replace(' ', ''))
        except Exception:
            return 35.0
    else:
        try:
            return float(t.replace('d', '').replace(' ', ''))
        except Exception:
            return 25.0


def _compute_foam_and_fabric_price(dims: List[Tuple[float, float]], thickness: float, density: float) -> Tuple[float, float]:
    """Calcule les totaux TTC de mousse et de tissu pour une liste de coussins.

    Pour chaque coussin, le prix de la mousse est :

      (longueur * largeur * épaisseur * densité * 23) / 1 000 000

    Le prix du tissu est déterminé par la largeur et l’épaisseur : si
    ``largeur + (épaisseur * 2) > 140`` alors ``(longueur/100) * 105`` sinon
    ``(longueur/100) * 74``.
    """
    foam_total = 0.0
    fabric_total = 0.0
    for L, W in dims:
        foam_total += (L * W * thickness * density * 23.0) / 1_000_000.0
        if (W + (thickness * 2.0)) > 140.0:
            fabric_total += (L / 100.0) * 105.0
        else:
            fabric_total += (L / 100.0) * 74.0
    return foam_total, fabric_total


def calculer_prix_total(
    *,
    type_canape: str,
    tx: float | int | None = None,
    ty: float | int | None = None,
    tz: float | int | None = None,
    profondeur: float | int | None = None,
    type_coussins: str | int | None = None,
    type_mousse: str | None = None,
    epaisseur: float | int | None = None,
    acc_left: bool = False,
    acc_right: bool = False,
    acc_bas: bool = False,
    dossier_left: bool = False,
    dossier_bas: bool = False,
    dossier_right: bool = False,
    nb_coussins_deco: int = 0,
    nb_traversins_supp: int = 0,
    has_surmatelas: bool | int = False,
    has_meridienne: bool | None = None,
    meridienne_side: str | None = None,
    meridienne_len: float | int | None = None,
    arrondis: bool | int = False
) -> Dict[str, float]:
    """Calcule le prix total TTC et fournit un détail complet des calculs.

    Le paramètre ``arrondis`` indique si les arrondis doivent être facturés
    (20 € par banquette droite ou d’angle).  Les autres paramètres
    reflètent directement les champs du formulaire Streamlit.
    """
    tx = float(tx or 0)
    ty = float(ty or 0)
    tz = float(tz or 0)
    profondeur = float(profondeur or 0)
    epaisseur_val = float(epaisseur or 0)
    density = _density_from_type(type_mousse or 'D25')
    mod = _load_canape_module()
    try:
        report = _call_render_function(
            mod,
            type_canape=type_canape,
            tx=tx,
            ty=ty,
            tz=tz,
            profondeur=profondeur,
            dossier_left=dossier_left,
            dossier_bas=dossier_bas,
            dossier_right=dossier_right,
            acc_left=acc_left,
            acc_bas=acc_bas,
            acc_right=acc_right,
            meridienne_side=meridienne_side,
            meridienne_len=meridienne_len or 0,
            coussins=type_coussins or 'auto'
        )
    except Exception:
        raise
    data = _parse_console_report(report)
    dims = list(data.get('dims_mousses', []))
    dims_angle = list(data.get('dims_mousses_angle', []))
    foam_straight, fabric_straight = _compute_foam_and_fabric_price(dims, epaisseur_val, density)
    foam_angle, fabric_angle = _compute_foam_and_fabric_price(dims_angle, epaisseur_val, density)
    foam_total = foam_straight + foam_angle
    fabric_total = fabric_straight + fabric_angle
    nb_banquettes = int(data.get('nb_banquettes') or 0)
    nb_banquettes_angle = int(data.get('nb_banquettes_angle') or 0)
    nb_dossiers = int(data.get('nb_dossiers') or 0)
    support_total = 0.0
    # Banquette droite est désormais facturée 250 € (au lieu de 225 €)
    support_total += nb_banquettes * 250.0
    support_total += nb_banquettes_angle * 250.0
    support_total += nb_dossiers * 250.0
    nb_coussins_65 = int(data.get('nb_coussins_65') or 0)
    nb_coussins_80 = int(data.get('nb_coussins_80') or 0)
    nb_coussins_90 = int(data.get('nb_coussins_90') or 0)
    nb_coussins_valise = int(data.get('nb_coussins_valise') or 0)
    cushion_total = (
        nb_coussins_65 * 40.0 +
        nb_coussins_80 * 50.0 +
        nb_coussins_90 * 55.0 +
        nb_coussins_valise * 75.0 +
        nb_coussins_deco * 15.0
    )
    nb_traversins = int(data.get('nb_traversins') or 0) + int(nb_traversins_supp or 0)
    traversin_total = nb_traversins * 30.0
    # Le nombre de surmatelas doit correspondre au nombre total de mousses (droites et d'angle)
    # lorsqu'ils sont activés. On calcule donc une unité par coussin si has_surmatelas est vrai.
    nb_surmatelas = (len(dims) + len(dims_angle)) if has_surmatelas else 0
    surmatelas_total = nb_surmatelas * 80.0
    nb_accoudoirs = int(data.get('nb_accoudoirs') or 0)
    accoudoir_total = nb_accoudoirs * 200.0
    details: List[Dict[str, object]] = []
    # Détails mousse et tissu par coussin droit
    for idx, (length, width) in enumerate(dims, start=1):
        foam_price = (length * width * epaisseur_val * density * 23.0) / 1_000_000.0
        details.append({
            'category': 'foam',
            'item': f'Mousse droite {idx} ({length}×{width} cm)',
            'quantity': 1,
            'unit_price': round(foam_price, 2),
            'formula': f'({length}*{width}*{epaisseur_val}*{density}*23)/1 000 000',
            'total_price': round(foam_price, 2)
        })
        if (width + (epaisseur_val * 2)) > 140:
            fabric_unit = (length / 100.0) * 105.0
            fabric_formula = f'({length}/100)*105'
        else:
            fabric_unit = (length / 100.0) * 74.0
            fabric_formula = f'({length}/100)*74'
        details.append({
            'category': 'fabric',
            'item': f'Tissu droite {idx} ({length}×{width} cm)',
            'quantity': 1,
            'unit_price': round(fabric_unit, 2),
            'formula': fabric_formula,
            'total_price': round(fabric_unit, 2)
        })
    # Détails mousse et tissu pour coussins d’angle
    for idx, (length, width) in enumerate(dims_angle, start=1):
        foam_price = (length * width * epaisseur_val * density * 23.0) / 1_000_000.0
        details.append({
            'category': 'foam',
            'item': f'Mousse angle {idx} ({length}×{width} cm)',
            'quantity': 1,
            'unit_price': round(foam_price, 2),
            'formula': f'({length}*{width}*{epaisseur_val}*{density}*23)/1 000 000',
            'total_price': round(foam_price, 2)
        })
        if (width + (epaisseur_val * 2)) > 140:
            fabric_unit = (length / 100.0) * 105.0
            fabric_formula = f'({length}/100)*105'
        else:
            fabric_unit = (length / 100.0) * 74.0
            fabric_formula = f'({length}/100)*74'
        details.append({
            'category': 'fabric',
            'item': f'Tissu angle {idx} ({length}×{width} cm)',
            'quantity': 1,
            'unit_price': round(fabric_unit, 2),
            'formula': fabric_formula,
            'total_price': round(fabric_unit, 2)
        })
    # Supports détaillés
    if nb_banquettes > 0:
        details.append({
            'category': 'support',
            'item': 'Banquette droite',
            'quantity': nb_banquettes,
            'unit_price': 250.0,
            'formula': '250 €/banquette',
            'total_price': round(nb_banquettes * 250.0, 2)
        })
    if nb_banquettes_angle > 0:
        details.append({
            'category': 'support',
            'item': 'Banquette d’angle',
            'quantity': nb_banquettes_angle,
            'unit_price': 250.0,
            'formula': '250 €/angle',
            'total_price': round(nb_banquettes_angle * 250.0, 2)
        })
    if nb_dossiers > 0:
        details.append({
            'category': 'support',
            'item': 'Dossier',
            'quantity': nb_dossiers,
            'unit_price': 250.0,
            'formula': '250 €/dossier',
            'total_price': round(nb_dossiers * 250.0, 2)
        })
    # Coussins détaillés
    if nb_coussins_65 > 0:
        details.append({
            'category': 'cushion',
            'item': 'Coussin 65 cm',
            'quantity': nb_coussins_65,
            'unit_price': 40.0,
            'formula': '40 €/coussin 65cm',
            'total_price': round(nb_coussins_65 * 40.0, 2)
        })
    if nb_coussins_80 > 0:
        details.append({
            'category': 'cushion',
            'item': 'Coussin 80 cm',
            'quantity': nb_coussins_80,
            'unit_price': 50.0,
            'formula': '50 €/coussin 80cm',
            'total_price': round(nb_coussins_80 * 50.0, 2)
        })
    if nb_coussins_90 > 0:
        details.append({
            'category': 'cushion',
            'item': 'Coussin 90 cm',
            'quantity': nb_coussins_90,
            'unit_price': 55.0,
            'formula': '55 €/coussin 90cm',
            'total_price': round(nb_coussins_90 * 55.0, 2)
        })
    if nb_coussins_valise > 0:
        details.append({
            'category': 'cushion',
            'item': 'Coussin valise',
            'quantity': nb_coussins_valise,
            'unit_price': 75.0,
            'formula': '75 €/coussin valise',
            'total_price': round(nb_coussins_valise * 75.0, 2)
        })
    if nb_coussins_deco > 0:
        details.append({
            'category': 'cushion',
            'item': 'Coussin déco',
            'quantity': nb_coussins_deco,
            'unit_price': 15.0,
            'formula': '15 €/coussin déco',
            'total_price': round(nb_coussins_deco * 15.0, 2)
        })
    # Traversins détaillés
    if nb_traversins > 0:
        details.append({
            'category': 'traversin',
            'item': 'Traversin',
            'quantity': nb_traversins,
            'unit_price': 30.0,
            'formula': '30 €/traversin',
            'total_price': round(nb_traversins * 30.0, 2)
        })
    # Surmatelas détaillés
    if nb_surmatelas > 0:
        details.append({
            'category': 'surmatelas',
            'item': 'Surmatelas',
            'quantity': nb_surmatelas,
            'unit_price': 80.0,
            'formula': '80 €/surmatelas',
            'total_price': round(nb_surmatelas * 80.0, 2)
        })
    # Accoudoirs détaillés
    if nb_accoudoirs > 0:
        details.append({
            'category': 'accoudoir',
            'item': 'Accoudoir',
            'quantity': nb_accoudoirs,
            'unit_price': 200.0,
            'formula': '200 €/accoudoir',
            'total_price': round(accoudoir_total, 2)
        })
    # Arrondis
    arrondis_units = 0
    arrondis_total = 0.0
    if arrondis:
        arrondis_units = nb_banquettes + nb_banquettes_angle
        arrondis_total = arrondis_units * 20.0
        details.append({
            'category': 'arrondis',
            'item': 'Arrondi',
            'quantity': arrondis_units,
            'unit_price': 20.0,
            'formula': '20 €/banquette ou angle',
            'total_price': round(arrondis_total, 2)
        })
    # Total TTC (somme de tous les composants, déjà TTC)
    total_ttc = (foam_total + fabric_total + support_total + cushion_total +
                 traversin_total + surmatelas_total + accoudoir_total + arrondis_total)
    prix_ht = round(total_ttc / 1.20, 2)
    tva = round(total_ttc - prix_ht, 2)
    # Le coût de revient initial basé sur 70 % du HT n'est plus utilisé :
    cout_revient_ht = round(prix_ht * 0.70, 2)  # conservé pour compatibilité mais remplacé plus bas
    # === Calcul du coût de revient détaillé (HT) ===
    # Coût de revient de la mousse selon la densité : coefficients spécifiques
    density_coeff_map = {
        'D25': 157.5,
        'D30': 188.0,
        'HR35': 192.0,
        'HR45': 245.0,
    }
    coeff_cr = density_coeff_map.get(type_mousse or 'D25', density_coeff_map['D25'])
    cr_foam_total = 0.0
    cr_fabric_total = 0.0
    cr_details: List[Dict[str, object]] = []
    # Coût de revient mousse et tissu pour chaque coussin droit
    for idx, (length, width) in enumerate(dims, start=1):
        # Déterminer si la dimension correspond à une mousse standard avec tarif fixe
        std_key = (int(round(length)), int(round(width)))
        is_std_size = (epaisseur_val == 25.0) and std_key in {
            (200, 70), (200, 80), (90, 90), (100, 100)
        }
        if is_std_size:
            # Tarifs fixes pour mousse standard (par densité)
            std_foam_prices = {
                (200, 70): {'D25': 42.55, 'D30': 51.0, 'HR35': 65.0, 'HR45': 84.0},
                (200, 80): {'D25': 63.0, 'D30': 75.2, 'HR35': 76.2, 'HR45': 98.0},
                (90, 90): {'D25': 31.9, 'D30': 38.1, 'HR35': 38.9, 'HR45': 49.6},
                (100, 100): {'D25': 39.3, 'D30': 47.0, 'HR35': 48.0, 'HR45': 61.20}
            }
            std_fabric_prices = {
                (200, 70): 34.40, (200, 80): 34.40, (90, 90): 28.40, (100, 100): 28.40
            }
            # Sélectionner le prix standard en fonction de la densité (type de mousse)
            foam_price_std = std_foam_prices[std_key].get(type_mousse or 'D25', std_foam_prices[std_key]['D25'])
            fabric_price_std = std_fabric_prices[std_key]
            cr_foam = foam_price_std
            cr_fabric = fabric_price_std
            cr_formula_foam = 'prix standard'
            cr_formula_fabric = 'prix standard'
        else:
            # Calcul conventionnel de la mousse
            cr_foam = (length * width * epaisseur_val) / 1_000_000.0 * coeff_cr
            cr_formula_foam = f'({length}*{width}*{epaisseur_val})/1 000 000*{coeff_cr}'
            # Calcul conventionnel du tissu
            if (2.0 + width + epaisseur_val * 2.0) <= 140.0:
                cr_fabric = (length / 100.0) * 11.2 + 15.0
                cr_formula_fabric = f'({length}/100)*11.2+15'
            else:
                cr_fabric = (length / 100.0) * 16.16 + 15.0
                cr_formula_fabric = f'({length}/100)*16.16+15'
        cr_foam_total += cr_foam
        cr_details.append({
            'category': 'foam',
            'item': f'Mousse droite {idx} ({length}×{width} cm)',
            'quantity': 1,
            'unit_price': round(cr_foam, 2),
            'formula': cr_formula_foam,
            'total_price': round(cr_foam, 2)
        })
        cr_fabric_total += cr_fabric
        cr_details.append({
            'category': 'fabric',
            'item': f'Tissu droite {idx} ({length}×{width} cm)',
            'quantity': 1,
            'unit_price': round(cr_fabric, 2),
            'formula': cr_formula_fabric,
            'total_price': round(cr_fabric, 2)
        })
    # Coût de revient mousse et tissu pour les coussins d’angle
    for idx, (length, width) in enumerate(dims_angle, start=1):
        # Déterminer si la dimension d'angle est standard
        std_key = (int(round(length)), int(round(width)))
        is_std_size = (epaisseur_val == 25.0) and std_key in {
            (200, 70), (200, 80), (90, 90), (100, 100)
        }
        if is_std_size:
            std_foam_prices = {
                (200, 70): {'D25': 42.55, 'D30': 51.0, 'HR35': 65.0, 'HR45': 84.0},
                (200, 80): {'D25': 63.0, 'D30': 75.2, 'HR35': 76.2, 'HR45': 98.0},
                (90, 90): {'D25': 31.9, 'D30': 38.1, 'HR35': 38.9, 'HR45': 49.6},
                (100, 100): {'D25': 39.3, 'D30': 47.0, 'HR35': 48.0, 'HR45': 61.20}
            }
            std_fabric_prices = {
                (200, 70): 34.40, (200, 80): 34.40, (90, 90): 28.40, (100, 100): 28.40
            }
            cr_foam = std_foam_prices[std_key].get(type_mousse or 'D25', std_foam_prices[std_key]['D25'])
            cr_fabric = std_fabric_prices[std_key]
            cr_formula_foam = 'prix standard'
            cr_formula_fabric = 'prix standard'
        else:
            cr_foam = (length * width * epaisseur_val) / 1_000_000.0 * coeff_cr
            cr_formula_foam = f'({length}*{width}*{epaisseur_val})/1 000 000*{coeff_cr}'
            if (2.0 + width + epaisseur_val * 2.0) <= 140.0:
                cr_fabric = (length / 100.0) * 11.2 + 15.0
                cr_formula_fabric = f'({length}/100)*11.2+15'
            else:
                cr_fabric = (length / 100.0) * 16.16 + 15.0
                cr_formula_fabric = f'({length}/100)*16.16+15'
        cr_foam_total += cr_foam
        cr_details.append({
            'category': 'foam',
            'item': f'Mousse angle {idx} ({length}×{width} cm)',
            'quantity': 1,
            'unit_price': round(cr_foam, 2),
            'formula': cr_formula_foam,
            'total_price': round(cr_foam, 2)
        })
        cr_fabric_total += cr_fabric
        cr_details.append({
            'category': 'fabric',
            'item': f'Tissu angle {idx} ({length}×{width} cm)',
            'quantity': 1,
            'unit_price': round(cr_fabric, 2),
            'formula': cr_formula_fabric,
            'total_price': round(cr_fabric, 2)
        })
    # Coût de revient des supports (banquettes, angles et dossiers)
    cr_support_total = 0.0
    # Banquettes droites
    if nb_banquettes > 0:
        for i in range(nb_banquettes):
            L = dims[i][0] if i < len(dims) else 0.0
            # Déterminer le coût selon la longueur
            if L <= 200.0:
                cr_sup = 93.0 + 8.0 * 2.5
                cr_sup_formula = '93+8*2.5'
            else:
                cr_sup = 98.5 + 22.5
                cr_sup_formula = '98.5+22.5'
            cr_support_total += cr_sup
        cr_details.append({
            'category': 'support',
            'item': 'Banquette droite',
            'quantity': nb_banquettes,
            'unit_price': round(cr_support_total / nb_banquettes, 2) if nb_banquettes else 0.0,
            'formula': cr_sup_formula,
            'total_price': round(cr_support_total, 2)
        })
    # Banquettes d’angle
    if nb_banquettes_angle > 0:
        cr_sup_angle_unit = 93.0 + 8.0 * 1.4
        cr_support_total += cr_sup_angle_unit * nb_banquettes_angle
        cr_details.append({
            'category': 'support',
            'item': 'Banquette d’angle',
            'quantity': nb_banquettes_angle,
            'unit_price': round(cr_sup_angle_unit, 2),
            'formula': '93+8*1.4',
            'total_price': round(cr_sup_angle_unit * nb_banquettes_angle, 2)
        })
    # Dossiers
    cr_dossier_total = 0.0
    if nb_dossiers > 0:
        cr_dossier_unit = 132.0 + 8.0 * 5.5
        cr_dossier_total = cr_dossier_unit * nb_dossiers
        # Ajouter une ligne séparée pour les dossiers sans les incorporer au total des banquettes
        cr_details.append({
            'category': 'support',
            'item': 'Dossier',
            'quantity': nb_dossiers,
            'unit_price': round(cr_dossier_unit, 2),
            'formula': '132+8*5.5',
            'total_price': round(cr_dossier_total, 2)
        })
    # Coût de revient des accoudoirs
    cr_accoudoir_total = nb_accoudoirs * 73.0
    if nb_accoudoirs > 0:
        cr_details.append({
            'category': 'accoudoir',
            'item': 'Accoudoir',
            'quantity': nb_accoudoirs,
            'unit_price': 73.0,
            'formula': '73',
            'total_price': round(cr_accoudoir_total, 2)
        })
    # Coût de revient des coussins (assise et déco) et autres accessoires
    cr_cushion_total = 0.0
    if nb_coussins_65 > 0:
        cr_cushion_total += nb_coussins_65 * 14.0
        cr_details.append({
            'category': 'cushion',
            'item': 'Coussin 65 cm',
            'quantity': nb_coussins_65,
            'unit_price': 14.0,
            'formula': '14',
            'total_price': round(nb_coussins_65 * 14.0, 2)
        })
    if nb_coussins_80 > 0:
        cr_cushion_total += nb_coussins_80 * 17.0
        cr_details.append({
            'category': 'cushion',
            'item': 'Coussin 80 cm',
            'quantity': nb_coussins_80,
            'unit_price': 17.0,
            'formula': '17',
            'total_price': round(nb_coussins_80 * 17.0, 2)
        })
    if nb_coussins_90 > 0:
        cr_cushion_total += nb_coussins_90 * 17.5
        cr_details.append({
            'category': 'cushion',
            'item': 'Coussin 90 cm',
            'quantity': nb_coussins_90,
            'unit_price': 17.5,
            'formula': '17.5',
            'total_price': round(nb_coussins_90 * 17.5, 2)
        })
    if nb_coussins_valise > 0:
        cr_cushion_total += nb_coussins_valise * 25.0
        cr_details.append({
            'category': 'cushion',
            'item': 'Coussin valise',
            'quantity': nb_coussins_valise,
            'unit_price': 25.0,
            'formula': '25',
            'total_price': round(nb_coussins_valise * 25.0, 2)
        })
    # Coussins déco
    cr_deco_total = nb_coussins_deco * 9.5
    if nb_coussins_deco > 0:
        cr_details.append({
            'category': 'cushion',
            'item': 'Coussin déco',
            'quantity': nb_coussins_deco,
            'unit_price': 9.5,
            'formula': '9.5',
            'total_price': round(cr_deco_total, 2)
        })
    # Traversins
    cr_traversin_total = nb_traversins * 11.6
    if nb_traversins > 0:
        cr_details.append({
            'category': 'traversin',
            'item': 'Traversin',
            'quantity': nb_traversins,
            'unit_price': 11.6,
            'formula': '11.6',
            'total_price': round(cr_traversin_total, 2)
        })
    # Surmatelas
    cr_surmatelas_total = nb_surmatelas * 31.0
    if nb_surmatelas > 0:
        cr_details.append({
            'category': 'surmatelas',
            'item': 'Surmatelas',
            'quantity': nb_surmatelas,
            'unit_price': 31.0,
            'formula': '31',
            'total_price': round(cr_surmatelas_total, 2)
        })
    # Arrondis
    cr_arrondis_total = 0.0
    cr_arrondis_units = 0
    if arrondis:
        cr_arrondis_units = nb_banquettes + nb_banquettes_angle
        cr_arrondis_total = cr_arrondis_units * 6.05
        cr_details.append({
            'category': 'arrondis',
            'item': 'Arrondi',
            'quantity': cr_arrondis_units,
            'unit_price': 6.05,
            'formula': '6.05',
            'total_price': round(cr_arrondis_total, 2)
        })
    # Livraison : coût de revient fixe de 100€
    cr_delivery_total = 100.0
    cr_details.append({
        'category': 'livraison',
        'item': 'Livraison',
        'quantity': 1,
        'unit_price': 100.0,
        'formula': '100',
        'total_price': 100.0
    })
    # Total coût de revient HT : addition de toutes les composantes sans double comptage
    cr_total_ht = (
        cr_foam_total + cr_fabric_total +
        cr_support_total + cr_dossier_total + cr_accoudoir_total +
        cr_cushion_total + cr_deco_total + cr_traversin_total +
        cr_surmatelas_total + cr_arrondis_total + cr_delivery_total
    )

    # Recalculer la marge HT : marge = prix de vente TTC / 1.2 - coût de revient HT
    marge_ht = round((total_ttc / 1.20) - cr_total_ht, 2)

    # Mettre à jour le coût de revient HT avec le calcul réel (écrase la version 70 %)
    cout_revient_ht = round(cr_total_ht, 2)

    return {
        'prix_ht': prix_ht,
        'tva': tva,
        'total_ttc': round(total_ttc, 2),
        'foam_total': round(foam_total, 2),
        'fabric_total': round(fabric_total, 2),
        'support_total': round(support_total, 2),
        'cushion_total': round(cushion_total, 2),
        'traversin_total': round(traversin_total, 2),
        'surmatelas_total': round(surmatelas_total, 2),
        'accoudoir_total': round(accoudoir_total, 2),
        'arrondis_total': round(arrondis_total, 2),
        'calculation_details': details,
        # --- Informations de coût de revient ---
        'cr_foam_total': round(cr_foam_total, 2),
        'cr_fabric_total': round(cr_fabric_total, 2),
        'cr_support_total': round(cr_support_total, 2),
        'cr_dossier_total': round(cr_dossier_total, 2),
        'cr_accoudoir_total': round(cr_accoudoir_total, 2),
        'cr_cushion_total': round(cr_cushion_total, 2),
        'cr_deco_total': round(cr_deco_total, 2),
        'cr_traversin_total': round(cr_traversin_total, 2),
        'cr_surmatelas_total': round(cr_surmatelas_total, 2),
        'cr_arrondis_total': round(cr_arrondis_total, 2),
        'cr_delivery_total': round(cr_delivery_total, 2),
        'cout_revient_ht': round(cr_total_ht, 2),
        'marge_ht': marge_ht,
        'calculation_details_cr': cr_details,
    }
